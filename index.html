<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Ben 10: Pet Guardians</title>
  <style>
     body{margin:0;background:#111;color:#fff;font-family:Arial,Helvetica,sans-serif;overflow:hidden;touch-action:none}
     #gameContainer{position:fixed;top:0;left:0;width:100vw;height:100vh}
     canvas{background:#222;display:block;border:2px solid #0ff;position:absolute;top:0;left:0;width:100%;height:100%;box-sizing:border-box}
     #hud{position:fixed;top:env(safe-area-inset-top, 10px);left:50%;transform:translateX(-50%);font-size:16px;background:rgba(0,0,0,0.7);padding:5px 15px;border-radius:20px;z-index:10}
     #score{position:fixed;top:env(safe-area-inset-top, 10px);right:10px;font-size:14px;background:rgba(0,0,0,0.7);padding:5px 10px;border-radius:15px;z-index:10}
     #controls{position:fixed;bottom:env(safe-area-inset-bottom, 20px);width:100%;display:none;touch-action:none;z-index:10}
     #joystick{position:absolute;left:15px;bottom:15px;width:100px;height:100px;background:rgba(255,255,255,0.15);border-radius:50%;border:2px solid rgba(255,255,255,0.4)}
     #joystickKnob{position:absolute;width:35px;height:35px;background:rgba(255,255,255,0.6);border-radius:50%;left:32.5px;top:32.5px}
     #attackBtn{position:absolute;right:15px;bottom:15px;width:70px;height:70px;background:rgba(255,0,0,0.4);border-radius:50%;border:2px solid rgba(255,0,0,0.6);display:flex;align-items:center;justify-content:center;font-size:22px}
     #omniBtn{position:absolute;right:95px;bottom:25px;width:55px;height:55px;background:rgba(0,255,0,0.4);border-radius:50%;border:2px solid rgba(0,255,0,0.6);display:flex;align-items:center;justify-content:center;font-size:14px}
     #omniBtn.active{background:rgba(0,255,0,0.8);box-shadow:0 0 20px rgba(0,255,0,0.8)}
     #omniHelp{position:fixed;bottom:env(safe-area-inset-bottom, 100px);left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.8);color:#0f0;padding:10px 20px;border-radius:20px;font-size:14px;display:none;z-index:20}
     @media (max-width:768px){#hud{font-size:14px;top:max(env(safe-area-inset-top, 10px), 10px)}#score{font-size:12px}}
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="game"></canvas>
    <div id="hud">Health: <span id="hp">100</span> | Wave: <span id="wave">1</span> | <span id="form">Ben</span></div>
    <div id="score">Score: <span id="scoreVal">0</span></div>
    <div id="controls">
      <div id="joystick"><div id="joystickKnob"></div></div>
      <button id="attackBtn">⚡</button>
      <button id="omniBtn">⌚</button>
    </div>
    <div id="omniHelp">Hold ⌚ then tap alien on wheel</div>
  </div>

<script>
/* ---------- SETUP ---------- */
const cvs = document.getElementById('game'), ctx = cvs.getContext('2d');
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

// Set CSS variables for safe areas
document.documentElement.style.setProperty('--sat', getComputedStyle(document.documentElement).paddingTop);
document.documentElement.style.setProperty('--sab', getComputedStyle(document.documentElement).paddingBottom);

// Responsive canvas
function resizeCanvas() {
  const container = document.getElementById('gameContainer');
  const controlsHeight = isMobile ? 150 : 0; // Reserve space for controls
  const safeAreaTop = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sat') || '0');
  const safeAreaBottom = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sab') || '0');
  
  if (isMobile) {
    // Mobile: use full width minus borders, adjust height for controls
    cvs.width = container.clientWidth - 4; // Account for 2px borders
    cvs.height = container.clientHeight - controlsHeight - safeAreaTop - safeAreaBottom - 4;
  } else {
    // Desktop: maintain aspect ratio
    const maxWidth = container.clientWidth;
    const maxHeight = container.clientHeight;
    const aspectRatio = 4/3;
    
    let width = maxWidth;
    let height = width / aspectRatio;
    
    if (height > maxHeight) {
      height = maxHeight;
      width = height * aspectRatio;
    }
    
    cvs.width = Math.min(width, 1024);
    cvs.height = Math.min(height, 768);
  }
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Show controls on mobile
if (isMobile) {
  document.getElementById('controls').style.display = 'block';
}

/* ---------- INPUT SYSTEM ---------- */
const keys = {};
let mouse = {x:0,y:0};
let joystickActive = false;
let joystickVector = {x:0,y:0};

// Desktop controls
if (!isMobile) {
  window.onkeydown = e => keys[e.code] = true;
  window.onkeyup   = e => keys[e.code] = false;
  cvs.onmousemove = e => { 
    const r=cvs.getBoundingClientRect(); 
    mouse.x=(e.clientX-r.left)*(cvs.width/r.width); 
    mouse.y=(e.clientY-r.top)*(cvs.height/r.height); 
  };
  cvs.onmousedown = e => keys['Mouse0'] = true;
  cvs.onmouseup   = e => keys['Mouse0'] = false;
}
cvs.oncontextmenu = e => e.preventDefault();

// Mobile controls
if (isMobile) {
  const joystick = document.getElementById('joystick');
  const knob = document.getElementById('joystickKnob');
  const attackBtn = document.getElementById('attackBtn');
  const omniBtn = document.getElementById('omniBtn');
  
  // Virtual joystick
  function handleTouch(e, isStart) {
    e.preventDefault();
    const touch = e.touches[0];
    if (!touch && !isStart) {
      joystickActive = false;
      joystickVector = {x:0,y:0};
      knob.style.left = '32.5px';
      knob.style.top = '32.5px';
      return;
    }
    
    if (touch) {
      const rect = joystick.getBoundingClientRect();
      const centerX = rect.left + rect.width/2;
      const centerY = rect.top + rect.height/2;
      const dx = touch.clientX - centerX;
      const dy = touch.clientY - centerY;
      const distance = Math.min(Math.hypot(dx,dy), 32.5);
      const angle = Math.atan2(dy,dx);
      
      joystickActive = true;
      joystickVector.x = Math.cos(angle) * (distance/32.5);
      joystickVector.y = Math.sin(angle) * (distance/32.5);
      
      knob.style.left = (32.5 + Math.cos(angle)*distance) + 'px';
      knob.style.top = (32.5 + Math.sin(angle)*distance) + 'px';
    }
  }
  
  joystick.addEventListener('touchstart', e => handleTouch(e, true));
  joystick.addEventListener('touchmove', handleTouch);
  joystick.addEventListener('touchend', e => handleTouch(e, false));
  
  // Attack button
  attackBtn.addEventListener('touchstart', e => { e.preventDefault(); keys['Attack'] = true; });
  attackBtn.addEventListener('touchend', e => { e.preventDefault(); keys['Attack'] = false; });
  
  // Omnitrix button with visual feedback
  omniBtn.addEventListener('touchstart', e => { 
    e.preventDefault(); 
    keys['Space'] = true; 
    omniBtn.classList.add('active');
    document.getElementById('omniHelp').style.display = 'block';
  });
  omniBtn.addEventListener('touchend', e => { 
    e.preventDefault(); 
    keys['Space'] = false; 
    omniBtn.classList.remove('active');
    document.getElementById('omniHelp').style.display = 'none';
  });
  
  // Touch for aiming and Omnitrix selection
  cvs.addEventListener('touchstart', e => {
    e.preventDefault();
    const touch = e.touches[0];
    const r = cvs.getBoundingClientRect();
    mouse.x = (touch.clientX-r.left)*(cvs.width/r.width);
    mouse.y = (touch.clientY-r.top)*(cvs.height/r.height);
    
    // Check if Omnitrix is open and tap is on wheel
    if(omniOpen) {
      keys['Mouse0'] = true;
      setTimeout(() => keys['Mouse0'] = false, 100);
    }
  });
  
  cvs.addEventListener('touchmove', e => {
    e.preventDefault();
    const touch = e.touches[0];
    const r = cvs.getBoundingClientRect();
    mouse.x = (touch.clientX-r.left)*(cvs.width/r.width);
    mouse.y = (touch.clientY-r.top)*(cvs.height/r.height);
  });
}

/* ---------- ASSETS ---------- */
const benImg = new Image();
benImg.src = 'ben10.gif';

/* ---------- GAME STATE ---------- */
const player = {
  x:400,y:300, hp:100, maxHp:100, speed:4,
  form:'ben', cooldown:0, invulnerable:0, score:0,
  pets:[
    {type:'stinkfly', x:0,y:0, cooldown:0, color:'#0f8'},
    {type:'heatblast',x:0,y:0, cooldown:0, color:'#f50'},
    {type:'grey',     x:0,y:0, cooldown:0, color:'#88f'}
  ]
};

const aliens = {
  ben:       {hp:100,speed:4,atk:10,color:'#2a5',range:150},
  heatblast: {hp:120,speed:3.5,atk:20,color:'#f50',range:250},
  fourarms:  {hp:180,speed:2.5,atk:30,color:'#c55',range:80},
  xlr8:      {hp:80, speed:7,atk:12,color:'#0cf',range:120},
  cannonbolt:{hp:160,speed:5,atk:25,color:'#fb0',range:100}
};

const enemyTypes = {
  basic: {hp:30,speed:1,atk:10,color:'#a0a',size:30,score:10},
  fast:  {hp:20,speed:2.5,atk:8,color:'#f0f',size:25,score:15},
  tank:  {hp:60,speed:0.5,atk:15,color:'#808',size:40,score:20},
  ranged:{hp:25,speed:1,atk:12,color:'#f8a',size:28,score:25,range:150}
};

let enemies = [];
let projectiles = [];
let particles = [];
let pickups = [];
let wave = 1;
let omniOpen = false;

/* ---------- PARTICLES ---------- */
function createParticles(x,y,color,count=10) {
  for(let i=0;i<count;i++) {
    particles.push({
      x,y,
      vx:(Math.random()-0.5)*4,
      vy:(Math.random()-0.5)*4,
      life:30,
      color,
      size:Math.random()*3+2
    });
  }
}

/* ---------- PICKUPS ---------- */
function spawnPickup(x,y) {
  if(Math.random()<0.15) { // 15% chance
    pickups.push({
      x,y,
      type:'health',
      value:20,
      life:300
    });
  }
}

/* ---------- OMNITRIX WHEEL ---------- */
function drawWheel() {
  // Position wheel in center of screen on mobile for easier access
  const cx = isMobile ? cvs.width/2 : player.x;
  const cy = isMobile ? cvs.height/2 : player.y-100;
  const radius = isMobile ? 100 : 80;
  
  ctx.save();
  ctx.globalAlpha = 0.95;
  
  // Background
  ctx.fillStyle='#000';
  ctx.beginPath();
  ctx.arc(cx,cy,radius,0,Math.PI*2);
  ctx.fill();
  
  // Green rim
  ctx.strokeStyle='#0f0';
  ctx.lineWidth=3;
  ctx.stroke();
  
  const list = Object.keys(aliens);
  const slice = Math.PI*2 / list.length;
  
  // Calculate selected based on mouse/touch position
  const dx = mouse.x - cx, dy = mouse.y - cy;
  let selectedIdx = -1;
  if (Math.hypot(dx,dy) < radius && Math.hypot(dx,dy) > 20) {
    let angle = Math.atan2(dy,dx) + Math.PI/2;
    if(angle < 0) angle += Math.PI*2;
    selectedIdx = Math.floor(angle/slice) % list.length;
  }
  
  list.forEach((name,i)=>{
    const angle = slice*i - Math.PI/2;
    const x = cx + Math.cos(angle)*radius*0.6;
    const y = cy + Math.sin(angle)*radius*0.6;
    
    // Highlight selected
    if(i === selectedIdx) {
      ctx.fillStyle='rgba(0,255,0,0.3)';
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,radius,angle-slice/2,angle+slice/2);
      ctx.closePath();
      ctx.fill();
    }
    
    // Alien icon
    ctx.fillStyle = aliens[name].color;
    ctx.beginPath();
    ctx.arc(x,y,20,0,Math.PI*2);
    ctx.fill();
    
    // Name
    ctx.fillStyle='#fff';
    ctx.font='bold 12px Arial';
    ctx.textAlign='center';
    ctx.fillText(name.toUpperCase(),x,y+4);
  });
  
  // Center
  ctx.fillStyle='#0f0';
  ctx.beginPath();
  ctx.arc(cx,cy,15,0,Math.PI*2);
  ctx.fill();
  
  ctx.restore();
}

/* ---------- GAME LOOP ---------- */
let last=0;
function gameLoop(ts){
  const dt = Math.min(ts-last, 50); // Cap dt to prevent huge jumps
  last=ts;
  update(dt);
  render();
  requestAnimationFrame(gameLoop);
}

function update(dt){
  // Handle invulnerability
  if(player.invulnerable > 0) player.invulnerable -= dt;
  
  // Omnitrix toggle
  if(keys['Space']) { 
    omniOpen = true; 
  } else { 
    omniOpen = false; 
  }
  
  // Movement
  let dx=0, dy=0;
  if(joystickActive) {
    dx = joystickVector.x;
    dy = joystickVector.y;
  } else {
    if(keys['KeyW']||keys['ArrowUp'])    dy--;
    if(keys['KeyS']||keys['ArrowDown'])  dy++;
    if(keys['KeyA']||keys['ArrowLeft'])  dx--;
    if(keys['KeyD']||keys['ArrowRight']) dx++;
    const len = Math.hypot(dx,dy);
    if(len){ dx/=len; dy/=len; }
  }
  
  const spd = aliens[player.form].speed;
  const margin = 25; // Increased margin for mobile
  player.x = Math.max(margin,Math.min(cvs.width-margin, player.x+dx*spd));
  player.y = Math.max(margin,Math.min(cvs.height-margin, player.y+dy*spd));
  
  // Pets follow and attack
  player.pets.forEach((p,i)=>{
    const angle = Date.now()/500 + i*Math.PI*2/3;
    p.x = player.x + Math.cos(angle)*50;
    p.y = player.y + Math.sin(angle)*50;
    
    // Pet attacks
    if(p.cooldown > 0) p.cooldown -= dt;
    if(p.cooldown <= 0 && enemies.length > 0) {
      // Find nearest enemy
      let nearest = null;
      let minDist = Infinity;
      enemies.forEach(e => {
        const dist = Math.hypot(e.x-p.x, e.y-p.y);
        if(dist < minDist && dist < 150) {
          minDist = dist;
          nearest = e;
        }
      });
      
      if(nearest) {
        const a = Math.atan2(nearest.y-p.y, nearest.x-p.x);
        projectiles.push({
          x:p.x, y:p.y,
          vx:Math.cos(a)*6, vy:Math.sin(a)*6,
          life:20,
          dmg:5,
          color:p.color,
          isPet:true
        });
        p.cooldown = 1000;
      }
    }
  });
  
  // Player attack
  if(player.cooldown>0) player.cooldown-=dt;
  if((keys['Mouse0'] || keys['Attack']) && !omniOpen && player.cooldown<=0){
    // Auto-aim for mobile
    let targetX = mouse.x;
    let targetY = mouse.y;
    
    if(isMobile && enemies.length > 0) {
      // Find nearest enemy for auto-aim
      let nearest = enemies[0];
      let minDist = Math.hypot(enemies[0].x-player.x, enemies[0].y-player.y);
      enemies.forEach(e => {
        const dist = Math.hypot(e.x-player.x, e.y-player.y);
        if(dist < minDist) {
          minDist = dist;
          nearest = e;
        }
      });
      targetX = nearest.x;
      targetY = nearest.y;
    }
    
    const a = Math.atan2(targetY-player.y, targetX-player.x);
    const range = aliens[player.form].range;
    
    // Special attacks for different forms
    if(player.form === 'heatblast') {
      // Fire spread
      for(let i=-1; i<=1; i++) {
        projectiles.push({
          x:player.x, y:player.y,
          vx:Math.cos(a+i*0.2)*8, vy:Math.sin(a+i*0.2)*8,
          life:range/8,
          dmg: aliens[player.form].atk,
          color: '#ff5500',
          size: 8
        });
      }
    } else if(player.form === 'cannonbolt') {
      // Big projectile
      projectiles.push({
        x:player.x, y:player.y,
        vx:Math.cos(a)*6, vy:Math.sin(a)*6,
        life:range/6,
        dmg: aliens[player.form].atk,
        color: aliens[player.form].color,
        size: 15
      });
    } else {
      // Normal projectile
      projectiles.push({
        x:player.x, y:player.y,
        vx:Math.cos(a)*10, vy:Math.sin(a)*10,
        life:range/10,
        dmg: aliens[player.form].atk,
        color: aliens[player.form].color,
        size: 6
      });
    }
    player.cooldown = player.form === 'xlr8' ? 150 : 300;
  }
  
  // Omnitrix selection
  if (omniOpen && (keys['Mouse0'] || keys['Attack'])) {
    const cx = isMobile ? cvs.width/2 : player.x;
    const cy = isMobile ? cvs.height/2 : player.y - 100;
    const radius = isMobile ? 100 : 80;
    const dx = mouse.x - cx, dy = mouse.y - cy;
    if (Math.hypot(dx, dy) < radius && Math.hypot(dx, dy) > 20) {
      const list = Object.keys(aliens);
      const slice = Math.PI * 2 / list.length;
      let angle = Math.atan2(dy, dx) + Math.PI / 2;
      if (angle < 0) angle += Math.PI * 2;
      const idx = Math.floor(angle / slice) % list.length;
      const newForm = list[idx];
      if(newForm !== player.form) {
        player.form = newForm;
        player.hp = Math.min(player.hp, aliens[newForm].hp);
        player.maxHp = aliens[newForm].hp;
        createParticles(player.x, player.y, aliens[newForm].color, 20);
      }
    }
  }
  
  // Update projectiles
  projectiles = projectiles.filter(p=>{
    p.x+=p.vx; p.y+=p.vy; p.life--;
    return p.life>0 && p.x>0 && p.x<cvs.width && p.y>0 && p.y<cvs.height;
  });
  
  // Update particles
  particles = particles.filter(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.2; // gravity
    p.life--;
    return p.life > 0;
  });
  
  // Update pickups
  pickups = pickups.filter(p => {
    p.life--;
    // Check collection
    if(Math.hypot(p.x-player.x, p.y-player.y) < 30) {
      if(p.type === 'health') {
        player.hp = Math.min(player.maxHp, player.hp + p.value);
        createParticles(p.x, p.y, '#0f0', 15);
      }
      return false;
    }
    return p.life > 0;
  });
  
  // Spawn enemies
  if(enemies.length === 0){
    for(let i=0; i<wave+2; i++){
      const types = Object.keys(enemyTypes);
      const typeChance = Math.random();
      let type = 'basic';
      
      if(wave > 2 && typeChance < 0.3) type = 'fast';
      if(wave > 4 && typeChance < 0.2) type = 'tank';
      if(wave > 6 && typeChance < 0.15) type = 'ranged';
      
      const side = Math.floor(Math.random()*4);
      let x,y;
      switch(side) {
        case 0: x=Math.random()*cvs.width; y=-30; break;
        case 1: x=cvs.width+30; y=Math.random()*cvs.height; break;
        case 2: x=Math.random()*cvs.width; y=cvs.height+30; break;
        case 3: x=-30; y=Math.random()*cvs.height; break;
      }
      
      enemies.push({
        x, y,
        type,
        hp: enemyTypes[type].hp + wave*2,
        maxHp: enemyTypes[type].hp + wave*2,
        speed: enemyTypes[type].speed,
        hitCooldown: 0,
        shootCooldown: 0
      });
    }
    wave++;
  }
  
  // Update enemies
  enemies.forEach(e=>{
    const et = enemyTypes[e.type];
    
    if(e.hitCooldown > 0) e.hitCooldown -= dt;
    
    // Movement (except ranged which keeps distance)
    if(e.type !== 'ranged' || Math.hypot(player.x-e.x,player.y-e.y) > 200) {
      const a = Math.atan2(player.y-e.y,player.x-e.x);
      e.x += Math.cos(a)*et.speed;
      e.y += Math.sin(a)*et.speed;
    }
    
    // Ranged enemy shoots
    if(e.type === 'ranged') {
      if(e.shootCooldown > 0) e.shootCooldown -= dt;
      if(e.shootCooldown <= 0 && Math.hypot(player.x-e.x,player.y-e.y) < et.range) {
        const a = Math.atan2(player.y-e.y,player.x-e.x);
        projectiles.push({
          x:e.x, y:e.y,
          vx:Math.cos(a)*5, vy:Math.sin(a)*5,
          life:30,
          dmg:et.atk,
          color:'#f88',
          isEnemy:true,
          size:4
        });
        e.shootCooldown = 2000;
      }
    }
    
    // Contact damage
    if(Math.hypot(player.x-e.x,player.y-e.y) < 30 && e.hitCooldown <= 0 && player.invulnerable <= 0){
      player.hp = Math.max(0, player.hp-et.atk);
      player.invulnerable = 1000; // 1 second of invulnerability
      e.hitCooldown = 1000;
      createParticles(player.x, player.y, '#f00', 10);
    }
  });
  
  // Projectile collisions
  projectiles.forEach(p=>{
    if(!p.isEnemy) {
      // Player/pet projectiles hit enemies
      enemies.forEach(e=>{
        const et = enemyTypes[e.type];
        if(Math.hypot(p.x-e.x,p.y-e.y) < et.size/2 + (p.size||6)/2){
          e.hp -= p.dmg;
          p.life = 0;
          createParticles(e.x, e.y, et.color, 5);
          
          if(e.hp <= 0) {
            player.score += et.score * wave;
            createParticles(e.x, e.y, et.color, 15);
            spawnPickup(e.x, e.y);
          }
        }
      });
    } else {
      // Enemy projectiles hit player
      if(Math.hypot(p.x-player.x,p.y-player.y) < 20 && player.invulnerable <= 0){
        player.hp = Math.max(0, player.hp-p.dmg);
        player.invulnerable = 1000;
        p.life = 0;
        createParticles(player.x, player.y, '#f00', 10);
      }
    }
  });
  
  // Remove dead enemies
  enemies = enemies.filter(e=>e.hp>0);
  
  // Game over
  if(player.hp <= 0){
    alert(`Game Over! Score: ${player.score}\nYou reached wave ${wave}`);
    location.reload();
  }
  
  // Update HUD
  document.getElementById('hp').textContent = player.hp;
  document.getElementById('wave').textContent = wave;
  document.getElementById('form').textContent = player.form.charAt(0).toUpperCase() + player.form.slice(1);
  document.getElementById('scoreVal').textContent = player.score;
}

function render(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  
  // Grid background
  ctx.strokeStyle = 'rgba(0,255,255,0.05)';
  ctx.lineWidth = 1;
  for(let x=0; x<cvs.width; x+=50) {
    ctx.beginPath();
    ctx.moveTo(x,0);
    ctx.lineTo(x,cvs.height);
    ctx.stroke();
  }
  for(let y=0; y<cvs.height; y+=50) {
    ctx.beginPath();
    ctx.moveTo(0,y);
    ctx.lineTo(cvs.width,y);
    ctx.stroke();
  }
  
  // Draw pickups
  pickups.forEach(p => {
    ctx.save();
    ctx.globalAlpha = p.life/300;
    ctx.fillStyle = '#0f0';
    ctx.fillRect(p.x-10, p.y-10, 20, 20);
    ctx.fillStyle = '#fff';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('+', p.x, p.y+5);
    ctx.restore();
  });
  
  // Draw particles
  particles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = p.life/30;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x-p.size/2, p.y-p.size/2, p.size, p.size);
    ctx.restore();
  });
  
  // Draw pets
  player.pets.forEach(p=>{
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 12, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
  });
  
  // Draw player
  if(player.invulnerable > 0 && Math.floor(player.invulnerable/100) % 2) {
    ctx.globalAlpha = 0.5;
  }
  
  if(benImg.complete && player.form === 'ben') {
    const scale = 0.6;
    ctx.drawImage(benImg,
      player.x - benImg.width*scale/2,
      player.y - benImg.height*scale/2,
      benImg.width*scale,
      benImg.height*scale);
  } else {
    // Draw alien form
    ctx.fillStyle = aliens[player.form].color;
    ctx.beginPath();
    ctx.arc(player.x, player.y, 25, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
  
  // Health bar
  const barWidth = 40;
  const barHeight = 4;
  ctx.fillStyle = '#333';
  ctx.fillRect(player.x-barWidth/2, player.y-35, barWidth, barHeight);
  ctx.fillStyle = '#0f0';
  ctx.fillRect(player.x-barWidth/2, player.y-35, barWidth*(player.hp/player.maxHp), barHeight);
  
  // Draw enemies
  enemies.forEach(e=>{
    const et = enemyTypes[e.type];
    ctx.fillStyle = et.color;
    
    if(e.type === 'tank') {
      // Square for tanks
      ctx.fillRect(e.x-et.size/2, e.y-et.size/2, et.size, et.size);
    } else {
      // Circle for others
      ctx.beginPath();
      ctx.arc(e.x, e.y, et.size/2, 0, Math.PI*2);
      ctx.fill();
    }
    
    // Enemy health bar
    if(e.hp < e.maxHp) {
      ctx.fillStyle = '#333';
      ctx.fillRect(e.x-20, e.y-et.size/2-10, 40, 3);
      ctx.fillStyle = '#f00';
      ctx.fillRect(e.x-20, e.y-et.size/2-10, 40*(e.hp/e.maxHp), 3);
    }
  });
  
  // Draw projectiles
  projectiles.forEach(p=>{
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size || 5, 0, Math.PI*2);
    ctx.fill();
  });
  
  // Draw Omnitrix wheel
  if(omniOpen) drawWheel();
}

// Start game
requestAnimationFrame(gameLoop);
</script>
</body>
</html>